--
-- This file has been pre-processed with DynASM.
-- http://luajit.org/dynasm.html
-- DynASM version 1.4.0_luamode, DynASM x64 version 1.4.0_luamode
-- DO NOT EDIT! The original file is in "lib/multi_copy.dasl".
--

-- Copy routines to stream multiple copies in parallel -*- lua -*-
--
-- For big hash tables, it is expected that we will have to go all the
-- way out to main memory every time you go to look up a value.  That's
-- pretty expensive: around 70 nanoseconds per cache miss.  We can reduce
-- this cost by making many fetches at once, and relying on the processor
-- to parallelize the requests.  In this way although we can expect
-- the latency for one lookup operation to be approximately the cost
-- of one cache miss, if the lookup returns N values the per-lookup
-- cost is divided by N.
--
-- See http://www.realworldtech.com/haswell-cpu/5/ for more on how the
-- memory subsystem works in a modern processor.

module(..., package.seeall)

local debug = false

local ffi = require("ffi")
local C = ffi.C

local dasm = require("dasm")

--|.arch x64
if dasm._VERSION ~= 10400 then
  error("Version mismatch between DynASM and included encoding engine")
end
--|.actionlist actions
local actions = ffi.new('const uint8_t[104]', {
  197,252,252,119,65,84,65,85,65,86,65,87,255,72,184,237,237,197,126,111,56,
  255,72,139,134,253,240,131,233,255,196,225,126,111,128,253,240,133,240,13,
  233,72,131,192,240,35,32,255,197,252,254,127,135,253,240,132,233,255,72,129,
  199,239,255,196,226,5,44,128,253,240,133,240,5,233,255,196,226,5,46,135,253,
  240,133,233,255,72,129,198,239,255,197,252,252,119,65,95,65,94,65,93,65,92,
  195,255
})


-- Table keeping machine code alive to the GC.
local anchor = {}

-- Utility: assemble code and optionally dump disassembly.
local function assemble (name, prototype, generator)
   local Dst = dasm.new(actions)
   generator(Dst)
   local mcode, size = Dst:build()
   table.insert(anchor, mcode)
   if debug then
      print("mcode dump: "..name)
      dasm.dump(mcode, size)
   end
   return ffi.cast(prototype, mcode)
end

local gencache = {} -- Cache for generated variants (reuse if possible.)
function gen(count, size)
   local function gen_multi_copy(Dst)
      -- dst in rdi
      -- src in rsi

      --| vzeroall
      --| push r12
      --| push r13
      --| push r14
      --| push r15
      dasm.put(Dst, 0)

      local tail_size = size % 32
      local tail_mask
      if tail_size ~= 0 then
         assert(tail_size % 4 == 0, '4-byte alignment required')
         tail_mask = ffi.new("uint8_t[32]")
         for i=0,tail_size-1 do tail_mask[i]=255 end
         table.insert(anchor, tail_mask)
         --| mov64 rax, tail_mask
         --| vmovdqu ymm15, [rax]
         dasm.put(Dst, 13, ffi.cast("uintptr_t", tail_mask) % 2^32, ffi.cast("uintptr_t", tail_mask) / 2^32)
      end

      -- Stream in data from up to 8 regions at once.
      while count > 0 do
         local stride = math.min(count, 8)
         local to_copy = size
         for i = 0, stride-1 do
            --| mov Rq(8+i), [rsi + 8*i]
            dasm.put(Dst, 22, (8+i), 8*i)
         end
         while to_copy >= 32 do
            local double_copy = to_copy >= 64 and not tail_mask
            local inc = double_copy and 64 or 32
            for i = 0, stride-1 do
               --| vmovdqu ymm(i), [Rq(8+i)]
               --| add Rq(8+i), 32
               dasm.put(Dst, 30, (i), (8+i), 0, (8+i))
               if double_copy then
                  --| vmovdqu ymm(8+i), [Rq(8+i)]
                  --| add Rq(8+i), 32
                  dasm.put(Dst, 30, (8+i), (8+i), 0, (8+i))
               end
            end
            for i = 0, stride-1 do
               --| vmovdqu [rdi + i*size], ymm(i)
               dasm.put(Dst, 48, (i), i*size)
               if double_copy then
                  --| vmovdqu [rdi + i*size+32], ymm(8+i)
                  dasm.put(Dst, 48, (8+i), i*size+32)
               end
            end
            --| add rdi, inc
            dasm.put(Dst, 58, inc)
            to_copy = to_copy - inc
         end

         if to_copy > 0 then
            for i = 0, stride-1 do
               --| vmaskmovps ymm(i), ymm15, [Rq(8+i)]
               dasm.put(Dst, 63, (i), (8+i), 0)
            end
            for i = 0, stride-1 do
               --| vmaskmovps [rdi + i*size], ymm15, ymm(i)
               dasm.put(Dst, 75, (i), i*size)
            end
            --| add rdi, to_copy
            dasm.put(Dst, 58, to_copy)
            to_copy = 0
         end

         -- Now the dst has been advanced by SIZE.  Increment for the
         -- parallel strides.
         --| add rdi, (stride-1)*size
         dasm.put(Dst, 58, (stride-1)*size)
         -- Increment the src as well.
         --| add rsi, stride*8
         dasm.put(Dst, 85, stride*8)
         count = count - stride
      end
      --| vzeroall
      --| pop r15
      --| pop r14
      --| pop r13
      --| pop r12
      --| ret
      dasm.put(Dst, 90)
   end
   local name = "multi_copy_"..size.."_"..count
   -- Assemble multi copy variant and cache it unless it has not been
   -- previously generated.
   if not gencache[name] then
      gencache[name] = assemble(name, "void(*)(void*, void*)", gen_multi_copy)
   end
   return gencache[name]
end

function selftest ()
   print("selftest: multi_copy")

   local cpuinfo = require('core.lib').readfile("/proc/cpuinfo", "*a")
   assert(cpuinfo, "failed to read /proc/cpuinfo for hardware check")
   if not cpuinfo:match("avx2") then
      print("selftest: not supported; avx2 unavailable")
      return
   end

   local src = ffi.new('uint8_t[78]',
                       { 1,
                         2, 2,
                         3, 3, 3,
                         4, 4, 4, 4,
                         5, 5, 5, 5, 5, -- o/~ golden rings o/~
                         6, 6, 6, 6, 6, 6,
                         7, 7, 7, 7, 7, 7, 7,
                         8, 8, 8, 8, 8, 8, 8, 8,
                         9, 9, 9, 9, 9, 9, 9, 9, 9,
                         10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
                         11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
                         12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12 })
   for size=4,76,4 do
      for count=1,10 do
         local dst = ffi.new('uint8_t['..100*count..']')
         local srcv = ffi.new('void*['..count..']')
         local multi_copy = gen(count, size)
         for offset=0,(78 - size - count)-1 do
            ffi.C.memset(dst, 0, 100*count)
            for i=0,count-1 do srcv[i] = src + offset + i end
            multi_copy(dst, srcv)
            for i=0,count-1 do
               for j=0,size-1 do assert(dst[i*size + j] == src[offset+i+j]) end
            end
            for i=count*size,100*count-1 do assert(dst[i] == 0) end
         end
      end
   end

   print("selftest: ok")
end
