--
-- This file has been pre-processed with DynASM.
-- http://luajit.org/dynasm.html
-- DynASM version 1.4.0_luamode, DynASM x64 version 1.4.0_luamode
-- DO NOT EDIT! The original file is in "apps/wall/scanner/ndpi_opt.dasl".
--

-- This module creates a wrapper around nDPI's packet processing
-- functions in order to help LuaJIT do its optimizations
--
-- Specifically, it avoids a struct value return by creating wrappers
-- that pass a struct pointer in instead. LuaJIT can handle that
-- better than a struct return (which is not supported).

module(..., package.seeall)

local dasm = require("dasm")
local ffi  = require("ffi")
local ndpi = require("ndpi.c").lib

local debug = false

--|.arch x64
if dasm._VERSION ~= 10400 then
  error("Version mismatch between DynASM and included encoding engine")
end
--|.actionlist actions
local actions = ffi.new('const uint8_t[64]', {
  72,139,68,36,8,80,255,72,184,237,237,252,255,208,72,131,196,8,255,72,139,
  76,36,16,72,137,1,72,137,81,4,255,195,255,72,131,252,236,8,72,184,237,237,
  252,255,208,72,131,196,8,255,72,139,76,36,8,72,137,1,72,137,81,4,255
})


-- the definitions here (anchor, assemble, gen) are borrowed from lwaftr
-- (see multi_copy.lua)
__anchor = {}

local function assemble (name, prototype, generator)
   local Dst = dasm.new(actions)
   generator(Dst)
   local mcode, size = Dst:build()
   table.insert(__anchor, mcode)
   if debug then
      print("mcode dump: "..name)
      dasm.dump(mcode, size)
   end
   return ffi.cast(prototype, mcode)
end

local function gen_ndppw(orig_f)
   local function gen(Dst)
      -- pass the first stack argument onto the original function
      --| mov rax, [rsp+8]
      --| push rax
      dasm.put(Dst, 0)

      -- call the original function, do stack cleanup
      --| mov64 rax, orig_f
      --| call rax
      --| add rsp, 8
      dasm.put(Dst, 7, ffi.cast("uintptr_t", orig_f) % 2^32, ffi.cast("uintptr_t", orig_f) / 2^32)

      -- at this point, rax and rdx have struct
      -- fields in them, which we want to write into
      -- the struct pointer (2nd stack arg)
      --| mov rcx, [rsp+16]
      --| mov [rcx], rax
      --| mov [rcx+4], rdx
      dasm.put(Dst, 19)

      --| ret
      dasm.put(Dst, 32)
   end

   return gen
end

local function gen_nupw(orig_f)
   local function gen(Dst)
      -- call the original function, aligning on 16
      --| sub rsp, 8
      --| mov64 rax, orig_f
      --| call rax
      --| add rsp, 8
      dasm.put(Dst, 34, ffi.cast("uintptr_t", orig_f) % 2^32, ffi.cast("uintptr_t", orig_f) / 2^32)

      -- like above, write into struct
      --| mov rcx, [rsp+8]
      --| mov [rcx], rax
      --| mov [rcx+4], rdx
      dasm.put(Dst, 51)

      --| ret
      dasm.put(Dst, 32)
   end

   return gen
end

-- see ljndpi/ndpi/c.lua for the corresponding headers for these functions
-- these have an extra void* argument at the end for the struct pointer
local function make_ndpp_wrapper(f)
   local wrap = assemble("ndpi_detection_process_packet_wrapper",
                         ffi.typeof("void (*)(void*, void*, void*, unsigned short, uint64_t, void*, void*, void*)"),
                         gen_ndppw(f))
   return function(self, flow, data, len, tick, src, dst)
             local proto = ffi.new("ndpi_protocol_t")
             wrap(self, flow, data, len, tick, src, dst, proto)
             return proto.master_protocol, proto.protocol
          end
end

local function make_ngup_wrapper(f)
   local wrap = assemble("ndpi_detection_process_packet_wrapper",
                         ffi.typeof("void (*)(void*, uint8_t, uint32_t, uint16_t, uint32_t, uint16_t, void*)"),
                         gen_nupw(f))
   return function(self, prot_n, src_h, src_p, dst_h, dst_p)
             local proto = ffi.new("ndpi_protocol_t")
             wrap(self, prot_n, src_h, src_p, dst_h, dst_p, proto)
             return proto.master_protocol, proto.protocol
          end
end

process_packet = make_ndpp_wrapper(ndpi.ndpi_detection_process_packet)
guess_undetected_protocol = make_ngup_wrapper(ndpi.ndpi_guess_undetected_protocol)
